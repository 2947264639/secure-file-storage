# 安全文件存储系统 - 功能流程详解文档

## 文档说明

本文档面向项目组员，详细讲解系统各功能的实现流程、关键代码位置以及涉及的信息安全原理。阅读本文档前，请先查看 README.md 了解项目基本信息和目录结构。

---

## 一、系统启动与密钥初始化

### 1.1 启动流程

**入口位置**：`SecureFileStorageApplication.java` 的 `main()` 方法

**流程说明**：
1. JavaFX 调用 `launch(args)` 启动应用
2. `init()` 方法初始化 Spring 容器（非 Web 模式）
3. `start()` 方法启动主窗口 UI
4. 主窗口初始化时自动调用密钥初始化流程

### 1.2 密钥初始化流程

**关键代码位置**：`MainWindow.java` 的 `initializeKeys()` 方法（约第 95 行）

**详细流程**：

```
检查密钥库文件是否存在 (./secure-storage/user.p12)
    ├─ 存在 → 加载现有密钥库
    │   ├─ KeyManagementService.loadKeyStore()
    │   ├─ 从密钥库提取私钥和公钥
    │   └─ 重建 KeyPair 对象
    │
    └─ 不存在 → 创建新密钥库
        ├─ KeyManagementService.createKeyStore()
        ├─ SignatureService.generateKeyPair() - 生成 RSA-2048 密钥对
        ├─ KeyManagementService.generateSelfSignedCertificate() - 生成 X.509 自签名证书
        ├─ 将密钥对和证书存入密钥库
        └─ 保存密钥库到磁盘
```

**涉及的信息安全原理**：

- **非对称加密密钥对**：系统为每个用户生成一对 RSA 密钥（公钥+私钥）
    - 公钥：用于加密和验证签名，可以公开
    - 私钥：用于解密和生成签名，必须保密

- **密钥库（KeyStore）**：使用 PKCS12 标准格式安全存储密钥
    - 密钥库本身使用密码保护（对称加密）
    - 私钥在密钥库中以加密形式存储
    - 提供了密钥的集中管理和访问控制

- **数字证书**：X.509 自签名证书将公钥与身份信息绑定
    - 证书包含：持有者信息、公钥、有效期、签名等
    - 自签名：证书由自己的私钥签名（适用于个人使用场景）

---

## 二、文件上传与加密流程

### 2.1 触发方式

**方式一**：点击"上传文件"按钮
- 代码位置：`MainWindow.java` 的 `handleUploadFile()` 方法（约第 281 行）

**方式二**：拖拽文件到窗口
- 代码位置：`MainWindow.java` 的 `setupDragAndDrop()` 方法（约第 245 行）

### 2.2 完整加密流程

**主流程代码位置**：
- UI 层：`MainWindow.java` 的 `uploadFile()` 方法（约第 294 行）
- 业务层：`FileStorageService.java` 的 `uploadAndEncryptFile()` 方法（约第 76 行）
- 加密层：`EncryptionService.java` 的 `encryptFile()` 方法（约第 67 行）

**详细流程图**：

```
用户选择文件
    ↓
弹出加密选项对话框
    ├─ 输入加密密码（两次确认）
    └─ 选择是否数字签名
    ↓
【第一步：计算原始文件哈希】
    ├─ IntegrityService.calculateFileHash()
    ├─ 使用 SHA-256 算法
    └─ 目的：后续验证文件完整性
    ↓
【第二步：密钥派生】（EncryptionService.deriveKeyFromPassword）
    ├─ 生成随机盐值 (32字节)
    ├─ 生成随机 IV (16字节)
    ├─ 使用 PBKDF2 算法从密码派生 AES-256 密钥
    │   └─ 参数：密码、盐值、65536次迭代、256位密钥长度
    └─ 目的：将用户的弱密码转换为强加密密钥
    ↓
【第三步：AES 加密】
    ├─ 算法：AES-256/CBC/PKCS5Padding
    ├─ 写入加密文件头：
    │   ├─ 盐值长度 + 盐值数据
    │   └─ IV 长度 + IV 数据
    ├─ 流式加密文件内容（8KB 缓冲区）
    └─ 保存到 secure-storage/encrypted/ 目录
    ↓
【第四步：数字签名】（如果用户勾选）
    ├─ SignatureService.signFile()
    ├─ 对原始文件计算 SHA-256 哈希
    ├─ 使用私钥对哈希值签名（SHA256withRSA）
    ├─ 签名结果保存为 Base64 编码
    └─ 保存到 secure-storage/signatures/ 目录
    ↓
【第五步：创建元数据】
    ├─ 生成唯一文件 ID (UUID)
    ├─ 记录文件信息（名称、大小、哈希、路径等）
    ├─ 记录加密和签名状态
    └─ 保存到内存映射表（fileMetadataMap）
    ↓
刷新文件列表显示
```

**涉及的信息安全原理**：

#### 2.2.1 密钥派生（Key Derivation）

**问题背景**：用户输入的密码通常较弱且长度不固定，不能直接用作加密密钥。

**解决方案**：PBKDF2（Password-Based Key Derivation Function 2）

**工作原理**：
- **盐值（Salt）**：32字节随机数，防止彩虹表攻击
    - 即使两个用户使用相同密码，盐值不同导致派生密钥不同
    - 每次加密使用不同的盐值

- **迭代次数**：65536 次哈希运算
    - 增加暴力破解成本（需要计算 65536 次才能测试一个密码）
    - 对合法用户影响小（只需计算一次）

- **输出**：固定 256 位的强加密密钥

#### 2.2.2 AES 加密模式

**算法选择**：AES-256（Advanced Encryption Standard）
- 256 位密钥长度，提供军用级加密强度
- 对称加密：加密和解密使用相同密钥

**工作模式**：CBC（Cipher Block Chaining）
- 明文分组加密，每组 16 字节
- 前一个密文块参与下一块加密（链式依赖）
- 优势：相同明文块产生不同密文（安全性更高）

**初始化向量（IV）**：
- 16 字节随机数
- 作为第一个明文块的"前驱"
- 每次加密使用不同 IV，确保相同文件加密结果不同

**填充方式**：PKCS5Padding
- 最后一块不足 16 字节时自动填充
- 填充内容：填充长度本身（如缺 5 字节则填充 5 个 0x05）

#### 2.2.3 数字签名

**目的**：证明文件来源和完整性

**签名生成流程**：
1. 计算文件 SHA-256 哈希（摘要）
2. 使用私钥对哈希值加密 → 生成签名
3. 签名附加在文件旁边

**安全保障**：
- 只有私钥持有者能生成有效签名
- 任何人都可以用公钥验证签名
- 文件被篡改后签名验证失败

---

## 三、文件解密流程

### 3.1 解密系统内文件

**触发位置**：点击"解密文件"按钮
- UI 代码：`MainWindow.java` 的 `handleDecryptFile()` 方法（约第 418 行）
- 业务代码：`FileStorageService.java` 的 `decryptFile()` 方法（约第 129 行）

**流程图**：

```
用户在列表中选择已加密文件
    ↓
弹出密码输入对话框
    ↓
【第一步：读取加密文件头】
    ├─ 读取盐值长度和盐值
    ├─ 读取 IV 长度和 IV
    └─ 这些参数是加密时写入的
    ↓
【第二步：密钥派生】
    ├─ 使用相同的 PBKDF2 算法
    ├─ 输入：用户密码 + 读取的盐值
    ├─ 参数：65536 次迭代、256 位输出
    └─ 派生出解密密钥（必须与加密密钥相同）
    ↓
【第三步：AES 解密】
    ├─ 初始化解密器（AES-256/CBC 模式）
    ├─ 使用派生密钥和读取的 IV
    ├─ 流式解密文件内容
    └─ 保存到 secure-storage/decrypted/ 目录
    ↓
【第四步：完整性验证】
    ├─ 计算解密文件的 SHA-256 哈希
    ├─ 与元数据中的原始哈希对比
    ├─ 不一致 → 删除解密文件，抛出异常
    └─ 一致 → 解密成功
    ↓
更新文件元数据（标记为已解密）
刷新文件列表
```

**关键代码位置**：`EncryptionService.java` 的 `decryptFile()` 方法（约第 105 行）

**涉及的信息安全原理**：

#### 3.1.1 对称加密的可逆性

- 加密和解密是互逆操作
- 必要条件：密钥、IV、算法模式完全相同
- 密码错误 → 派生密钥错误 → 解密失败（抛出异常）

#### 3.1.2 完整性验证的重要性

**为什么需要**：
- 解密成功 ≠ 文件正确
- 密码错误可能产生"垃圾数据"（解密器不会报错）
- 文件可能在存储过程中损坏

**验证机制**：
- 加密前记录文件哈希值
- 解密后重新计算哈希值
- 哈希不匹配 → 文件不完整或密码错误

**安全效果**：
- 防止使用错误密码导致的数据错误
- 检测存储介质错误
- 检测恶意篡改

### 3.2 解密外部加密文件

**触发方式**：拖拽 `.enc` 文件到窗口

**代码位置**：
- 检测逻辑：`MainWindow.java` 的 `uploadFile()` 方法（约第 297 行）
- 处理逻辑：`handleDecryptExternalFile()` 方法（约第 381 行）
- 业务逻辑：`FileStorageService.java` 的 `decryptExternalFile()` 方法（约第 174 行）

**流程特点**：
1. 无需元数据（不依赖系统记录）
2. 从文件名推断原始名称（去除 `.enc` 后缀）
3. 解密后自动查找对应的签名文件（`.sig`）
4. 创建新的元数据并加入系统管理

---

## 四、数字签名验证流程

### 4.1 验证触发

**位置**：点击"验证签名"按钮
- UI 代码：`MainWindow.java` 的 `handleVerifySignature()` 方法（约第 455 行）
- 业务代码：`FileStorageService.java` 的 `verifyFileSignature()` 方法（约第 259 行）
- 验证代码：`SignatureService.java` 的 `verifyFileSignature()` 方法（约第 62 行）

### 4.2 验证流程

```
用户选择已签名的文件
    ↓
【前置检查】
    ├─ 文件必须已解密（需要原始文件内容）
    └─ 文件必须有签名标记
    ↓
【第一步：重新计算文件哈希】
    ├─ 对解密后的文件计算 SHA-256 哈希
    └─ 得到文件的"指纹"
    ↓
【第二步：加载签名数据】
    ├─ 从 .sig 文件读取签名
    ├─ Base64 解码为字节数组
    └─ 签名是当时用私钥加密的哈希值
    ↓
【第三步：公钥验证】
    ├─ 使用公钥"解密"签名 → 得到原始哈希值
    ├─ 将原始哈希与重新计算的哈希对比
    ├─ 一致 → 验证通过
    └─ 不一致 → 验证失败
    ↓
显示验证结果
```

**关键代码位置**：`SignatureService.java` 的 `verifyFileSignature()` 方法（约第 62-82 行）

**涉及的信息安全原理**：

#### 4.2.1 数字签名的数学基础

**签名过程**（RSA）：
- 签名 = Hash(文件) ^ d mod n（d 是私钥指数）
- 只有私钥持有者能计算

**验证过程**：
- 原始哈希 = 签名 ^ e mod n（e 是公钥指数）
- 任何人都可以计算
- 对比"原始哈希"与"重新计算的哈希"

#### 4.2.2 签名提供的安全保障

**完整性**：文件被修改后哈希变化 → 验证失败

**认证性**（来源可信）：
- 只有私钥持有者能生成有效签名
- 验证通过 = 文件确实来自该用户

**不可否认性**：
- 私钥唯一且保密
- 签名者无法否认签过名

#### 4.2.3 为什么需要先解密

**原因**：
- 签名是对原始文件内容的签名
- 加密文件的哈希值与原始文件不同
- 必须解密后才能验证签名

**流程**：
```
上传时：原始文件 → 签名 → 加密
下载时：解密 → 原始文件 → 验证签名
```

---

## 五、密钥管理功能

### 5.1 密钥管理界面

**入口**：点击"密钥管理"按钮
- 代码位置：`MainWindow.java` 的 `handleKeyManagement()` 方法（约第 499 行）

**界面结构**：
- 标签页 1：密钥信息（查看当前密钥对详情）
- 标签页 2：导出密钥（公钥、私钥）
- 标签页 3：导入密钥
- 标签页 4：备份与恢复
- 标签页 5：证书信息

### 5.2 公钥导出流程

**代码位置**：
- UI：`MainWindow.java` 的 `handleExportPublicKey()` 方法（约第 708 行）
- 业务：`KeyManagementService.java` 的 `exportPublicKey()` 方法（约第 131 行）

**流程**：
```
用户点击"导出公钥"按钮
    ↓
选择保存位置（默认 public_key.pem）
    ↓
【编码公钥】
    ├─ 获取公钥的字节编码（X.509 格式）
    ├─ Base64 编码
    └─ 添加 PEM 格式头尾标记
        -----BEGIN PUBLIC KEY-----
        [Base64 编码的公钥数据]
        -----END PUBLIC KEY-----
    ↓
保存到文件
```

**用途**：分享给他人用于验证你的签名

### 5.3 私钥导出流程（加密保护）

**代码位置**：
- UI：`MainWindow.java` 的 `handleExportPrivateKey()` 方法（约第 738 行）
- 业务：`KeyManagementService.java` 的 `exportPrivateKey()` 方法（约第 157 行）

**流程**：
```
用户点击"导出私钥"按钮
    ↓
弹出密码设置对话框（两次确认）
    ↓
【加密私钥】
    ├─ 生成随机盐值（32 字节）
    ├─ 生成随机 IV（16 字节）
    ├─ 使用 PBKDF2 从密码派生 AES-256 密钥
    ├─ 用 AES 加密私钥字节数据
    └─ 文件结构：
        ├─ 盐值长度 + 盐值
        ├─ IV 长度 + IV
        └─ 加密后的私钥数据
    ↓
保存到文件（.enc 扩展名）
```

**涉及的信息安全原理**：

#### 5.3.1 私钥保护的重要性

**风险**：
- 私钥泄露 = 身份被冒充
- 可以伪造任何签名
- 可以解密所有发给你的加密消息

**保护措施**：
- 私钥本身用 AES 加密
- 使用独立的密码保护
- 导出文件无法被直接读取

#### 5.3.2 多层密钥保护体系

```
第一层：密钥库（PKCS12）
    ├─ 密钥库密码："keystore123"
    └─ 私钥条目密码：同样是 "keystore123"
    
第二层：导出文件加密
    ├─ 用户自定义密码
    └─ 独立于密钥库密码
    
第三层：操作系统文件权限
    └─ 限制文件访问
```

### 5.4 密钥库备份与恢复

**备份代码**：`MainWindow.java` 的 `handleBackupKeyStore()` 方法（约第 891 行）
**恢复代码**：`handleRestoreKeyStore()` 方法（约第 920 行）

**备份流程**：
```
点击"备份密钥库"
    ↓
选择备份位置
    ↓
复制整个 user.p12 文件
    ↓
备份包含：
    ├─ RSA 密钥对
    ├─ X.509 证书
    └─ 所有密钥库配置
```

**恢复流程**：
```
点击"从备份恢复"
    ↓
二次确认（会覆盖当前密钥库）
    ↓
复制备份文件覆盖 user.p12
    ↓
重新加载密钥库
    ↓
更新当前 KeyPair 对象
```

**安全建议**：
- 定期备份密钥库
- 备份文件异地存储
- 备份文件同样需要密码保护

### 5.5 证书验证

**代码位置**：
- 验证逻辑：`KeyManagementService.java` 的 `verifyCertificate()` 方法（约第 215 行）
- UI 处理：`MainWindow.java` 证书标签页（约第 682 行）

**验证内容**：
1. **有效期检查**：证书是否在有效期内
2. **签名验证**：证书签名是否正确
    - 自签名证书：用自己的公钥验证
    - CA 签名证书：用 CA 公钥验证

**证书信息包括**：
- 主题（Subject）：持有者身份
- 颁发者（Issuer）：自签名时与主题相同
- 序列号：唯一标识证书
- 算法：SHA256withRSA
- 有效期：开始和结束时间

---

## 六、文件删除流程

**触发位置**：点击"删除文件"按钮
- UI 代码：`MainWindow.java` 的 `handleDeleteFile()` 方法（约第 481 行）
- 业务代码：`FileStorageService.java` 的 `deleteFile()` 方法（约第 299 行）

**流程**：
```
用户选择文件并确认删除
    ↓
【删除加密文件】
    └─ secure-storage/encrypted/[fileId].enc
    ↓
【删除签名文件】（如果存在）
    └─ secure-storage/signatures/[fileId].sig
    ↓
【删除解密文件】（如果存在）
    └─ secure-storage/decrypted/[originalFileName]
    ↓
【删除元数据】
    └─ 从 fileMetadataMap 中移除记录
    ↓
刷新文件列表
```

**安全考虑**：
- 删除不可恢复（确认对话框）
- 同时删除所有相关文件
- 元数据同步删除

---

## 七、关键安全机制总结

### 7.1 密码保护层次

```
用户文件加密
    ├─ 用户输入密码
    ├─ PBKDF2 密钥派生（65536 次迭代）
    ├─ AES-256 加密
    └─ 随机盐值和 IV

私钥保护
    ├─ 存储在 PKCS12 密钥库
    ├─ 密钥库密码加密
    ├─ 导出时额外 AES 加密
    └─ 独立密码保护

签名私钥使用
    ├─ 从密钥库读取需要密码
    └─ 内存中临时使用
```

### 7.2 完整性保障链条

```
上传时
    ├─ 计算原始文件 SHA-256 哈希
    ├─ 记录在元数据中
    └─ （可选）生成 RSA 数字签名

解密时
    ├─ 重新计算哈希
    ├─ 与元数据中的哈希对比
    └─ 不匹配则拒绝

签名验证时
    ├─ 计算文件哈希
    ├─ 用公钥解密签名
    └─ 对比两个哈希值
```

### 7.3 随机性保障

**目的**：防止相同内容产生相同密文

**实现**：
- 每次加密使用不同的盐值（32 字节随机）
- 每次加密使用不同的 IV（16 字节随机）
- 使用 SecureRandom（密码学安全的随机数生成器）

**效果**：
- 同一文件多次加密结果不同
- 无法通过密文推断明文
- 防止频率分析攻击

### 7.4 密钥管理最佳实践

本系统实现的安全措施：
1. ✅ 密钥分离存储（密钥库独立于应用）
2. ✅ 密码保护（密钥库和私钥双重密码）
3. ✅ 支持密钥备份（防止密钥丢失）
4. ✅ 导出私钥加密（防止传输泄露）
5. ✅ 证书绑定（公钥与身份关联）

---

## 八、常见问题与安全提示

### Q1: 为什么解密前需要先加密？
A: 解密是独立操作，但验证签名需要原始文件。完整流程是：
- 有签名：上传 → 签名 → 加密；解密 → 验证签名
- 无签名：上传 → 加密；解密

### Q2: 忘记加密密码怎么办？
A: 无法恢复。PBKDF2 是单向函数，密码本身不存储。这是设计上的安全特性。

### Q3: 密钥库密码固定为 "keystore123" 是否安全？
A: 不完全安全。生产环境建议：
- 用户首次使用时设置密钥库密码
- 密码存储在配置文件中（加密保护）
- 或每次启动时要求输入密码

### Q4: 为什么需要两种哈希算法（SHA-1 和 SHA-256）？
A:
- SHA-1：满足课题要求
- SHA-256：更安全，实际使用
- IntegrityService 同时支持两种

### Q5: 自签名证书的局限性？
A:
- 只能自己验证
- 其他人无法确认证书真实性
- 适合个人使用或小范围信任
- 企业环境需要 CA 签名证书

---

## 九、代码阅读建议

推荐阅读顺序（从简单到复杂）：

1. **IntegrityService.java** - 最简单，理解哈希计算
2. **EncryptionService.java** - 理解加密/解密流程
3. **SignatureService.java** - 理解数字签名
4. **KeyManagementService.java** - 理解密钥管理
5. **FileStorageService.java** - 整合所有功能
6. **MainWindow.java** - UI 交互逻辑

关键调试点：
- 在 `encryptFile()` 设置断点，观察盐值和 IV 生成
- 在 `decryptFile()` 设置断点，观察密钥派生过程
- 在 `verifyFileSignature()` 设置断点，观察签名验证

---

## 十、安全性评估

本系统达到的安全等级：

| 安全特性 | 实现情况 | 说明 |
|---------|---------|------|
| 机密性 | ✅ 优秀 | AES-256 + 强密钥派生 |
| 完整性 | ✅ 优秀 | SHA-256 哈希 + 数字签名 |
| 认证性 | ✅ 良好 | RSA-2048 数字签名 |
| 不可否认性 | ✅ 良好 | 数字签名机制 |
| 密钥管理 | ✅ 良好 | PKCS12 + 多层保护 |
| 随机性 | ✅ 优秀 | SecureRandom + 独立盐值/IV |